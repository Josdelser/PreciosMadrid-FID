---
title: "Pricing"
output: html_document
date: "2023-01-04"
---
Paquetes y librerias
```{r}
install.packages("tidyverse")
install.packages("dplyr")
install.packages("rattle")
# libraries
library(rpart)
library(rpart.plot)
library(rattle)
library(dplyr)
library(ggplot2)
library(RColorBrewer)
library(caret)
library(readr)

set.seed(611)
```


Lectura del dataset 
```{r}
precios_madrid <- read.csv("PreciosMadrid.csv")
precios_madrid
colnames(precios_madrid)

```
Elijo las columnas que parecen mas interesantes
```{r}
predata1 <- select(precios_madrid,price,floor_built,bathrooms,terrace,bedrooms,postalcode,garage_included)
predata1
colnames(predata1)
```
Elimino pisos que cuesten 0, tengan 0 habitaciones,esten repetidos o sean NA. Tambien para acotar el dataset vamos a coger solo los anuncios de 10 postalcode
```{r}
predata2 = subset(predata1, price>0 & bedrooms>1 & postalcode>=28001 & postalcode<=28011)
predata2 <- na.omit(predata2)
predata <- unique(predata2)


```

Convertir las columnas de valores char("True","False") en num(1,0) y los distritos pasarlos a numeros para trabajar con ellos.Tambien estandarizo todo en numeric
```{r}
predata$terrace <- as.numeric(as.logical(predata$terrace))
predata$garage_included <- as.numeric(as.logical(predata$garage_included))
predata$postalcode <- as.numeric(as.integer(predata$postalcode))
predata$price <- as.numeric(as.integer(predata$price))
predata$floor_built <- as.numeric(as.integer(predata$floor_built))
predata$bathrooms <- as.numeric(as.integer(predata$bathrooms))
predata$bedrooms <- as.numeric(as.integer(predata$bedrooms))

```

Finalmente despues del preprocesamiento de datos, obtenemos el dataset final
```{r}
data<-predata

```


Una vez con los datos bien definido, pasamos a la visualización.

Primero vamos a ver el número de casas por código postal. 
```{r}
barplot(table(data$postalcode),
main="Número de casas por zona(Código Postal)",
xlab="Código Postal",
ylab="Número de casas",)
```

Vamos a etiquetar y categorizar según los metros construidos.
```{r}
data_metros <- data

data_metros[order(data_metros$floor_built),]
rangos <- c(0,65,100,150,Inf)
values <- c ('Piso','Duplex','Casa','Chalet')

data_metros$tipo <- cut(data_metros$floor_built, breaks = rangos, labels = values)

barplot(table(data_metros$tipo),
main="Número de casas según el tipo",
xlab="Tipo",
ylab="Número de casas",
col=c("red","orange","green","blue"),) 
```




Vamos a calcular el precio medio y metros construidos dependiendo de la zona donde vivas (Código postal)
```{r}

media1 <- aggregate(data[, 1:2], list(data$postalcode), mean)
media1

```

Vamos a graficar la media de precio según los metros construidos de media en  en barras

```{r}
ggplot(media1, aes(x = floor_built, y = price)) +
        geom_col()
```
Vamos a graficar la media de precio según los metros construidos de media por zonas en puntos
```{r}
#Pasamos a factor el codigo postal para ver mejor el codigo de colores
media1$Group.1 <- as.factor(as.numeric(media1$Group.1))
ggplot(media1, aes(x= floor_built, y=price, colour=Group.1)) + geom_point() 
```

Gráfica para saber dependiendo del tipo de casas si lleva garage o no. Podriamos hacer esto con las diferentes variables, solo habría que cambiar el valor del aes.

```{r}
a<- ggplot(data_metros, aes(garage_included)) 
a + geom_bar(aes(fill = tipo))

```


Gráfica según el número de tipos de casas por zona
```{r}
a<- ggplot(data_metros, aes(postalcode)) 

a + geom_bar(aes(fill = tipo))
```

Ahora vamos a realizar un arbol de decision sobre la variable precio.

Primero partimos el dataset para tener datos de entrenamiento y datos de validacion.
```{r}
train <-createDataPartition(data$price, p = 0.7, list=FALSE)
data_train <- data[train,]
data_val <- data[-train,]
nrow(data_train)
nrow(data_val)


```


Podemos ver las diferentes variables que afectan a su precio y en que nos podemos basar para aproximar el precio medio de una vivienda.
```{r}
arbol <- rpart(formula =  price  ~ ., data = data_train)
fancyRpartPlot(arbol)
```
Hacemos un par de cambios en la visualizacion para verlo mejor.
```{r}
prp(arbol, type = 2, nn = TRUE, 
    fallen.leaves = FALSE,
    varlen = 0,  shadow.col = "gray")
```
Vamos a ver el error relativo
```{r}
arbol$cptable
plotcp(arbol)

```

Podamos el arból para reducirlo
```{r}
arbol_podado <- prune(arbol, cp = 0.02)
prp(arbol_podado, type = 2, nn = TRUE, 
    fallen.leaves = FALSE,
    varlen = 0)

```
Predeccimos en el data de validacion y vemos que nos arroja los datos correctos
```{r}
precio_pred <- predict(arbol, newdata = data_val)


precio_pred[1]
```

Vamos a hacer predicciones con datos nuevo del precio según el arbol, construir la matriz de confusion y dibujar un arbol mas complejo. Para ello vamos a crear valores de pruebas.

```{r}
price <- c(0,0,0,0,0)
floor_built<- c(134,134,234,123,100)
bathrooms<- c(1,3,1,2,3)
terrace<- c(0,0,1,0,0)
bedrooms<- c(2,2,4,2,2)
postalcode<- c(28002,28002,28003,28003,28008)
garage_included<- c(1,1,0,0,1)

data_test_nuevo <- data.frame(price,floor_built,bathrooms,terrace,bedrooms,postalcode,garage_included)

#Construimos unos de pruebas y ponemos a 0 la columna del precio. 

#Predeccimos el precio segun el arbol
 nuevo_precio_pred <- predict(arbol, newdata = data_test_nuevo)
 
 
nuevo_precio_pred[1]
nuevo_precio_pred[2]


```




